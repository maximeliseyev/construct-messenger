# Пошаговая стратегия внедрения улучшений безопасности клиента

Этот документ описывает поэтапную стратегию реализации архитектуры безопасности на стороне клиента. План предполагает разделение клиента на два компонента: криптографическое **Ядро** на Rust и **Оболочку** UI (например, на Swift).

## Архитектура клиента

- **Ядро (Rust):** Содержит всю криптографию, логику E2E-протокола и управление состоянием сессий. Не имеет прямого доступа к сети или UI. Предоставляет четкий FFI (Foreign Function Interface) для вызова извне.
- **Оболочка (Swift/UI):** Отвечает за UI, взаимодействие с пользователем, сетевые запросы и безопасное хранение ключей (используя нативные средства платформы, например, iOS Keychain). Вызывает функции Ядра для выполнения крипто-графических операций.

---

## Фаза 1: Создание криптографического ядра (Foundation)

**Цель:** Построить гибкий и абстрактный крипто-движок, готовый к будущим изменениям.

1.  **Определить `CryptoProvider` Trait в Rust:**
    - Создать `trait`, который формализует все крипто-операции: `generate_keys`, `sign`, `verify`, `kem_encapsulate`, `kem_decapsulate`, `aead_encrypt` и т.д. Это основа крипто-гибкости.

2.  **Реализовать "классический" набор шифров:**
    - Создать первую конкретную реализацию `CryptoProvider` (например, `ClassicSuiteProvider`), использующую X25519 для KEM, Ed25519 для подписей и AES-256-GCM/ChaCha20-Poly1305 для AEAD. Использовать проверенные библиотеки (`ring`, `dalek-cryptography`).

3.  **Спроектировать FFI (C-интерфейс):**
    - Определить высокоуровневые функции для вызова из Swift (`create_session`, `encrypt_message`). FFI не должен допускать утечки сырых ключей или низкоуровневых деталей.
    - Использовать `cbindgen` для автоматической генерации заголовочных файлов C для импорта в Swift.

## Фаза 2: Реализация протокола 1-на-1

**Цель:** Обеспечить безопасное E2E-шифрование для двух участников.

1.  **Разработать логику управления ключами:**
    - Реализовать в Ядре создание **подписанного пакета ключей** (`signed key bundle`). Клиент должен уметь сгенерировать ключи, упаковать их в структуру (включая `Suite ID`), подписать ее своим ключом идентификации и отдать Оболочке для загрузки на сервер.

2.  **Реализовать установку сессии:**
    - Клиент (Алиса) через Оболочку запрашивает у сервера пакет ключей Боба.
    - **Критически важный шаг:** Ядро Rust должно верифицировать цифровую подпись этого пакета.
    - Ядро выполняет согласование набора шифров и производит обмен ключами (X3DH).
    - На этом же этапе реализуется концепция **"Пролога"** для криптографической привязки сессии к контексту участников.

3.  **Обеспечить безопасное хранение:**
    - Ядро никогда не хранит ключи на диске самостоятельно. Оно возвращает их Оболочке, которая обязана сохранять их в системном безопасном хранилище (**iOS Keychain**). При следующем запуске Оболочка загружает ключи и передает их в Ядро для восстановления состояния.

## Фаза 3: Внедрение постквантовой криптографии

**Цель:** Использовать заложенную в Фазе 1 гибкость для добавления PQ-защиты.

1.  **Реализовать PQ-гибридный `CryptoProvider`:**
    - Создать вторую реализацию `CryptoProvider` Trait. Для KEM использовать гибридную схему (например, X25519 + Kyber768), конкатенируя их общие секреты. Потребуется зависимость от библиотеки с PQ-алгоритмами (например, `liboqs-rs`).

2.  **Обновить логику согласования:**
    - Научить Ядро выбирать лучший (наиболее безопасный) общий набор шифров при установке сессии.

## Фаза 4: Групповые чаты (MLS)

**Цель:** Внедрить современный, безопасный и масштабируемый протокол для групп.

1.  **Интегрировать готовую MLS-библиотеку:**
    - Не реализовывать MLS с нуля. Использовать проверенную реализацию, например, **`openmls`**. Интеграция этой библиотеки будет отдельным большим проектом.

2.  **Реализовать клиентскую логику управления группами:**
    - Научить клиент обрабатывать изменения в составе группы от сервера.
    - **Критически важный шаг:** Реализовать в Ядре проверку **цифровой подписи на списке участников**. Клиент должен отклонять любые изменения состава группы, не подписанные легитимным администратором.

---

## Примечание о PWA и безопасности в браузере

Опасения по поводу безопасности мессенджера в браузере полностью оправданы. Ключевые сложности:
- **Хранение ключей:** В браузере нет надежного аналога iOS Keychain.
- **Доверие к коду:** Крипто-код, загружаемый с сервера, может быть подменен.
- **Уязвимости среды:** Браузер — это сложная среда, более подверженная атакам по сторонним каналам.

Концентрация на нативных клиентах является правильной стратегией для создания по-настояTщему безопасного мессенджера.
