//
//  CryptoManager.swift
//  Construct Messenger
//
//  Created by Maxim Eliseyev on 13.12.2025.
//  Updated for UniFFI clean API on 26.12.2025
//
//  This class is now a Swift wrapper around the UniFFI-generated Rust `construct-core` library.
//  Rust handles ALL crypto operations internally - Swift just passes wire format.
//

import Foundation
import os.log

class CryptoManager {
    static let shared = CryptoManager()

    // UniFFI ClassicCryptoCore object (automatically managed by Arc in Rust)
    private var core: ClassicCryptoCore?

    // Maps a user ID to a session ID generated by the Rust core
    private var userSessions: [String: String] = [:]

    private init() {
        do {
            // UniFFI: createCryptoCore() returns ClassicCryptoCore directly
            self.core = try createCryptoCore()
            Log.info("‚úÖ UniFFI CryptoCore initialized successfully!", category: "CryptoManager")
        } catch let error as CryptoError {
            // CryptoError is now the UniFFI-generated enum
            Log.fault("‚ùå Failed to create UniFFI CryptoCore: \(error)", category: "CryptoManager")
            fatalError("Failed to create UniFFI CryptoCore: \(error)")
        } catch {
            Log.fault("‚ùå Unexpected error creating CryptoCore: \(error)", category: "CryptoManager")
            fatalError("Unexpected error creating CryptoCore: \(error)")
        }
    }

    deinit {
        // UniFFI manages memory automatically via Arc<T>
        // No manual cleanup needed!
    }

    // MARK: - Registration

    /// Generates a complete bundle for server registration by calling the Rust core.
    func generateRegistrationBundle() -> RegistrationBundle? {
        guard let core = core else { return nil }

        do {
            // UniFFI: Returns JSON string directly (no RustString wrapper!)
            let jsonString = try core.exportRegistrationBundleJson()

            // Parse JSON into Swift struct
            guard let jsonData = jsonString.data(using: .utf8) else {
                Log.error("Failed to convert JSON string to Data", category: "CryptoManager")
                return nil
            }

            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let bundle = try decoder.decode(RegistrationBundle.self, from: jsonData)

            Log.info("‚úÖ Registration bundle generated successfully", category: "CryptoManager")
            return bundle
        } catch let error as CryptoError {
            Log.error("‚ùå Failed to generate registration bundle: \(error)", category: "CryptoManager")
            return nil
        } catch {
            Log.error("‚ùå Unexpected error generating bundle: \(error)", category: "CryptoManager")
            return nil
        }
    }

    // MARK: - Session Management

    /// Initializes a secure session with a recipient using the Rust core.
    func initializeSession(for userId: String, recipientBundle: (identityPublic: String, signedPrekeyPublic: String, signature: String, verifyingKey: String, suiteId: String)) throws {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }

        // 1. Decode base64 strings to Data
        guard let identityPublicData = Data(base64Encoded: recipientBundle.identityPublic),
              let signedPrekeyPublicData = Data(base64Encoded: recipientBundle.signedPrekeyPublic),
              let signatureData = Data(base64Encoded: recipientBundle.signature),
              let verifyingKeyData = Data(base64Encoded: recipientBundle.verifyingKey)
        else {
            Log.error("Failed to decode base64-encoded keys from bundle", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 2. Convert suiteId to UInt16
        guard let suiteID = UInt16(recipientBundle.suiteId) else {
            Log.error("Invalid suiteId format: \(recipientBundle.suiteId)", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 3. Create the dictionary for JSON serialization
        let bundleDict: [String: Any] = [
            "identity_public": [UInt8](identityPublicData),
            "signed_prekey_public": [UInt8](signedPrekeyPublicData),
            "signature": [UInt8](signatureData),
            "verifying_key": [UInt8](verifyingKeyData),
            "suite_id": suiteID,
        ]

        do {
            let bundleData = try JSONSerialization.data(withJSONObject: bundleDict)
            let bytes = [UInt8](bundleData)

            // UniFFI: initSession returns String directly (no RustString!)
            let sessionId = try core.initSession(contactId: userId, recipientBundle: bytes)

            self.userSessions[userId] = sessionId
            Log.info("‚úÖ Session initialized for user: \(userId)", category: "CryptoManager")
        } catch let error as CryptoError {
            Log.error("‚ùå Failed to initialize session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        } catch {
            Log.error("‚ùå Unexpected error initializing session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        }
    }

    /// Check if a session exists for a user
    func hasSession(for userId: String) -> Bool {
        return userSessions[userId] != nil
    }

    /// Delete a session for a user (called when deleting a chat)
    func deleteSession(for userId: String) {
        if let sessionId = userSessions[userId] {
            userSessions.removeValue(forKey: userId)
            Log.info("‚úÖ Session deleted for user: \(userId)", category: "CryptoManager")
        } else {
            Log.debug("No session found to delete for user: \(userId)", category: "CryptoManager")
        }
    }

    /// Initialize a receiving session (for responder/Bob) using sender's bundle + first message
    /// This is called when Bob receives the first message from Alice
    func initReceivingSession(for userId: String, recipientBundle: (identityPublic: String, signedPrekeyPublic: String, signature: String, verifyingKey: String, suiteId: String), firstMessage: ChatMessage) throws {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }

        // 1. Decode base64 strings to Data
        guard let identityPublicData = Data(base64Encoded: recipientBundle.identityPublic),
              let signedPrekeyPublicData = Data(base64Encoded: recipientBundle.signedPrekeyPublic),
              let signatureData = Data(base64Encoded: recipientBundle.signature),
              let verifyingKeyData = Data(base64Encoded: recipientBundle.verifyingKey)
        else {
            Log.error("Failed to decode base64-encoded keys from bundle", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 2. Convert suiteId to UInt16
        guard let suiteID = UInt16(recipientBundle.suiteId) else {
            Log.error("Invalid suiteId format: \(recipientBundle.suiteId)", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 3. Create the bundle dictionary for JSON serialization
        let bundleDict: [String: Any] = [
            "identity_public": [UInt8](identityPublicData),
            "signed_prekey_public": [UInt8](signedPrekeyPublicData),
            "signature": [UInt8](signatureData),
            "verifying_key": [UInt8](verifyingKeyData),
            "suite_id": suiteID,
        ]

        // 4. Create the first message dictionary
        let messageDict: [String: Any] = [
            "ephemeral_public_key": [UInt8](firstMessage.ephemeralPublicKey),
            "message_number": firstMessage.messageNumber,
            "content": firstMessage.content  // Base64 string
        ]

        do {
            let bundleData = try JSONSerialization.data(withJSONObject: bundleDict)
            let bundleBytes = [UInt8](bundleData)

            let messageData = try JSONSerialization.data(withJSONObject: messageDict)
            let messageBytes = [UInt8](messageData)

            // UniFFI: Call init_receiving_session
            let sessionId = try core.initReceivingSession(
                contactId: userId,
                recipientBundle: bundleBytes,
                firstMessage: messageBytes
            )

            self.userSessions[userId] = sessionId
            Log.info("‚úÖ Receiving session initialized for user: \(userId)", category: "CryptoManager")
        } catch let error as CryptoError {
            Log.error("‚ùå Failed to initialize receiving session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        } catch {
            Log.error("‚ùå Unexpected error initializing receiving session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        }
    }

    // MARK: - Encryption / Decryption

    /// Result of message encryption with separate fields per server ChatMessage spec
    struct EncryptedMessageComponents {
        let ephemeralPublicKey: Data  // dh_public_key (32 bytes) - sent as binary
        let messageNumber: UInt32
        let content: String  // Base64(nonce || ciphertext_with_tag)
    }

    /// Encrypts a plaintext message using the session for a specific user
    /// Returns separate components per server ChatMessage format
    func encryptMessage(_ message: String, for userId: String) throws -> EncryptedMessageComponents {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }
        guard let sessionId = userSessions[userId] else {
            throw CryptoManagerError.sessionNotFound
        }

        do {
            // ‚úÖ NEW CLEAN API: Rust returns wire format components directly
            let rustComponents = try core.encryptMessage(sessionId: sessionId, plaintext: message)

            // Convert to Swift struct
            let components = EncryptedMessageComponents(
                ephemeralPublicKey: Data(rustComponents.ephemeralPublicKey),
                messageNumber: rustComponents.messageNumber,
                content: rustComponents.content
            )

            Log.debug("‚úÖ ENCRYPT: msgNum=\(components.messageNumber), ephemKey=\(rustComponents.ephemeralPublicKey.prefix(8).map { String(format: "%02x", $0) }.joined()), content=\(components.content.prefix(20))...", category: "CryptoManager")
            return components
        } catch let error as CryptoError {
            Log.error("‚ùå Encryption failed: \(error)", category: "CryptoManager")
            throw CryptoManagerError.encryptionFailed
        } catch {
            Log.error("‚ùå Unexpected encryption error: \(error)", category: "CryptoManager")
            throw CryptoManagerError.encryptionFailed
        }
    }

    /// Decrypt a ChatMessage directly using clean API
    /// Uses clean API - Rust handles all MessagePack internally
    func decryptMessage(_ message: ChatMessage) throws -> String {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }
        guard let sessionId = userSessions[message.from] else {
            Log.error("‚ùå No session found for user: \(message.from)", category: "CryptoManager")
            throw CryptoManagerError.sessionNotFound
        }

        do {
            Log.debug("üì¶ Decrypting: ephemKey=\(message.ephemeralPublicKey.count) bytes, msgNum=\(message.messageNumber), content=\(message.content.prefix(20))...", category: "CryptoManager")

            // ‚úÖ NEW CLEAN API: Pass wire format components directly to Rust
            let plaintext = try core.decryptMessage(
                sessionId: sessionId,
                ephemeralPublicKey: [UInt8](message.ephemeralPublicKey),
                messageNumber: message.messageNumber,
                content: message.content
            )

            Log.debug("‚úÖ Message decrypted successfully, plaintext length: \(plaintext.count)", category: "CryptoManager")
            return plaintext
        } catch let error as CryptoError {
            Log.error("‚ùå Decryption failed: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        } catch {
            Log.error("‚ùå Unexpected decryption error: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        }
    }
}

// MARK: - Error Types

/// CryptoManager-specific errors (wraps UniFFI CryptoError)
enum CryptoManagerError: Error, LocalizedError {
    case coreNotInitialized
    case sessionNotFound
    case sessionInitializationFailed
    case encryptionFailed
    case decryptionFailed
    case invalidCiphertext
    case invalidKeyData

    var errorDescription: String? {
        switch self {
        case .coreNotInitialized:
            return "Crypto core is not initialized"
        case .sessionNotFound:
            return "No session found for this user"
        case .sessionInitializationFailed:
            return "Failed to initialize session"
        case .encryptionFailed:
            return "Failed to encrypt message"
        case .decryptionFailed:
            return "Failed to decrypt message"
        case .invalidCiphertext:
            return "Invalid ciphertext format"
        case .invalidKeyData:
            return "Invalid key data"
        }
    }
}
