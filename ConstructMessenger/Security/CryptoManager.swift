//
//  CryptoManager.swift
//  Construct Messenger
//
//  Created by Maxim Eliseyev on 13.12.2025.
//  Updated for UniFFI on 26.12.2025
//
//  This class is now a Swift wrapper around the UniFFI-generated Rust `construct-core` library.
//

import Foundation
import os.log
import MessagePack

class CryptoManager {
    static let shared = CryptoManager()

    // UniFFI ClassicCryptoCore object (automatically managed by Arc in Rust)
    private var core: ClassicCryptoCore?

    // Maps a user ID to a session ID generated by the Rust core
    private var userSessions: [String: String] = [:]

    private init() {
        do {
            // UniFFI: createCryptoCore() returns ClassicCryptoCore directly
            self.core = try createCryptoCore()
            Log.info("✅ UniFFI CryptoCore initialized successfully!", category: "CryptoManager")
        } catch let error as CryptoError {
            // CryptoError is now the UniFFI-generated enum
            Log.fault("❌ Failed to create UniFFI CryptoCore: \(error)", category: "CryptoManager")
            fatalError("Failed to create UniFFI CryptoCore: \(error)")
        } catch {
            Log.fault("❌ Unexpected error creating CryptoCore: \(error)", category: "CryptoManager")
            fatalError("Unexpected error creating CryptoCore: \(error)")
        }
    }

    deinit {
        // UniFFI manages memory automatically via Arc<T>
        // No manual cleanup needed!
    }

    // MARK: - Registration

    /// Generates a complete bundle for server registration by calling the Rust core.
    func generateRegistrationBundle() -> RegistrationBundle? {
        guard let core = core else { return nil }

        do {
            // UniFFI: Returns JSON string directly (no RustString wrapper!)
            let jsonString = try core.exportRegistrationBundleJson()

            // Parse JSON into Swift struct
            guard let jsonData = jsonString.data(using: .utf8) else {
                Log.error("Failed to convert JSON string to Data", category: "CryptoManager")
                return nil
            }

            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            let bundle = try decoder.decode(RegistrationBundle.self, from: jsonData)

            Log.info("✅ Registration bundle generated successfully", category: "CryptoManager")
            return bundle
        } catch let error as CryptoError {
            Log.error("❌ Failed to generate registration bundle: \(error)", category: "CryptoManager")
            return nil
        } catch {
            Log.error("❌ Unexpected error generating bundle: \(error)", category: "CryptoManager")
            return nil
        }
    }

    // MARK: - Session Management

    /// Initializes a secure session with a recipient using the Rust core.
    func initializeSession(for userId: String, recipientBundle: (identityPublic: String, signedPrekeyPublic: String, signature: String, verifyingKey: String, suiteId: String)) throws {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }

        // 1. Decode base64 strings to Data
        guard let identityPublicData = Data(base64Encoded: recipientBundle.identityPublic),
              let signedPrekeyPublicData = Data(base64Encoded: recipientBundle.signedPrekeyPublic),
              let signatureData = Data(base64Encoded: recipientBundle.signature),
              let verifyingKeyData = Data(base64Encoded: recipientBundle.verifyingKey)
        else {
            Log.error("Failed to decode base64-encoded keys from bundle", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 2. Convert suiteId to UInt16
        guard let suiteID = UInt16(recipientBundle.suiteId) else {
            Log.error("Invalid suiteId format: \(recipientBundle.suiteId)", category: "CryptoManager")
            throw CryptoManagerError.invalidKeyData
        }

        // 3. Create the dictionary for JSON serialization
        let bundleDict: [String: Any] = [
            "identity_public": [UInt8](identityPublicData),
            "signed_prekey_public": [UInt8](signedPrekeyPublicData),
            "signature": [UInt8](signatureData),
            "verifying_key": [UInt8](verifyingKeyData),
            "suite_id": suiteID,
        ]

        do {
            let bundleData = try JSONSerialization.data(withJSONObject: bundleDict)
            let bytes = [UInt8](bundleData)

            // UniFFI: initSession returns String directly (no RustString!)
            let sessionId = try core.initSession(contactId: userId, recipientBundle: bytes)

            self.userSessions[userId] = sessionId
            Log.info("✅ Session initialized for user: \(userId)", category: "CryptoManager")
        } catch let error as CryptoError {
            Log.error("❌ Failed to initialize session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        } catch {
            Log.error("❌ Unexpected error initializing session: \(error)", category: "CryptoManager")
            throw CryptoManagerError.sessionInitializationFailed
        }
    }

    /// Check if a session exists for a user
    func hasSession(for userId: String) -> Bool {
        return userSessions[userId] != nil
    }

    // MARK: - Encryption / Decryption

    /// Result of message encryption with separate fields per server ChatMessage spec
    struct EncryptedMessageComponents {
        let ephemeralPublicKey: Data  // dh_public_key (32 bytes) - sent as binary
        let messageNumber: UInt32
        let content: String  // Base64(nonce || ciphertext_with_tag)
    }

    /// Encrypts a plaintext message using the session for a specific user
    /// Returns separate components per server ChatMessage format
    func encryptMessage(_ message: String, for userId: String) throws -> EncryptedMessageComponents {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }
        guard let sessionId = userSessions[userId] else {
            throw CryptoManagerError.sessionNotFound
        }

        do {
            // UniFFI: encryptMessage returns [UInt8] - serialized EncryptedRatchetMessage (MessagePack format)
            let encryptedBytes = try core.encryptMessage(sessionId: sessionId, plaintext: message)

            // Deserialize EncryptedRatchetMessage from MessagePack
            let decoder = MessagePackDecoder()

            struct RatchetMessage: Codable {
                let dhPublicKey: [UInt8]  // 32 bytes
                let messageNumber: UInt32
                let ciphertext: [UInt8]  // Already contains auth tag from ChaCha20Poly1305
                let nonce: [UInt8]  // 12 bytes for ChaCha20
                let previousChainLength: UInt32
                let suiteId: UInt16

                // MessagePack uses snake_case from Rust, so we need custom keys
                enum CodingKeys: String, CodingKey {
                    case dhPublicKey = "dh_public_key"
                    case messageNumber = "message_number"
                    case ciphertext
                    case nonce
                    case previousChainLength = "previous_chain_length"
                    case suiteId = "suite_id"
                }
            }

            let ratchetMsg = try decoder.decode(RatchetMessage.self, from: Data(encryptedBytes))

            // Create ChaCha20Poly1305 sealed box format: nonce || ciphertext_with_tag
            var sealedBox = Data()
            sealedBox.append(contentsOf: ratchetMsg.nonce)  // 12 bytes
            sealedBox.append(contentsOf: ratchetMsg.ciphertext)  // ciphertext + 16-byte tag

            let components = EncryptedMessageComponents(
                ephemeralPublicKey: Data(ratchetMsg.dhPublicKey),
                messageNumber: ratchetMsg.messageNumber,
                content: sealedBox.base64EncodedString()
            )

            Log.debug("✅ Message encrypted - ephemeralKey: \(components.ephemeralPublicKey.count) bytes, sealed box: \(sealedBox.count) bytes (nonce: 12, ciphertext+tag: \(ratchetMsg.ciphertext.count))", category: "CryptoManager")
            return components
        } catch let error as CryptoError {
            Log.error("❌ Encryption failed: \(error)", category: "CryptoManager")
            throw CryptoManagerError.encryptionFailed
        } catch {
            Log.error("❌ Unexpected encryption error: \(error)", category: "CryptoManager")
            throw CryptoManagerError.encryptionFailed
        }
    }

    /// Decrypts a ciphertext using the session for a specific user
    func decryptMessage(_ ciphertext: Data, from userId: String) throws -> String {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }
        guard let sessionId = userSessions[userId] else {
            throw CryptoManagerError.sessionNotFound
        }

        do {
            let bytes = [UInt8](ciphertext)

            // UniFFI: decryptMessage returns String directly (no RustString!)
            let plaintext = try core.decryptMessage(sessionId: sessionId, ciphertext: bytes)

            Log.debug("✅ Message decrypted successfully", category: "CryptoManager")
            return plaintext
        } catch let error as CryptoError {
            Log.error("❌ Decryption failed: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        } catch {
            Log.error("❌ Unexpected decryption error: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        }
    }

    /// Decrypt a ChatMessage directly (convenience method)
    /// Reconstructs EncryptedRatchetMessage from ChatMessage fields
    func decryptMessage(_ message: ChatMessage) throws -> String {
        guard let core = core else {
            throw CryptoManagerError.coreNotInitialized
        }
        guard let sessionId = userSessions[message.from] else {
            throw CryptoManagerError.sessionNotFound
        }

        do {
            // Decode base64 sealed box: nonce || ciphertext_with_tag
            guard let sealedBox = Data(base64Encoded: message.content) else {
                throw CryptoManagerError.invalidCiphertext
            }

            // Extract nonce (first 12 bytes) and ciphertext (rest)
            guard sealedBox.count >= 12 else {
                throw CryptoManagerError.invalidCiphertext
            }

            let nonce = sealedBox.prefix(12)
            let ciphertextWithTag = sealedBox.suffix(from: 12)

            // Reconstruct EncryptedRatchetMessage
            struct RatchetMessage: Codable {
                let dhPublicKey: [UInt8]
                let messageNumber: UInt32
                let ciphertext: [UInt8]
                let nonce: [UInt8]
                let previousChainLength: UInt32  // Not used by decryption
                let suiteId: UInt16

                // MessagePack uses snake_case from Rust
                enum CodingKeys: String, CodingKey {
                    case dhPublicKey = "dh_public_key"
                    case messageNumber = "message_number"
                    case ciphertext
                    case nonce
                    case previousChainLength = "previous_chain_length"
                    case suiteId = "suite_id"
                }
            }

            let ratchetMsg = RatchetMessage(
                dhPublicKey: [UInt8](message.ephemeralPublicKey),
                messageNumber: message.messageNumber,
                ciphertext: [UInt8](ciphertextWithTag),
                nonce: [UInt8](nonce),
                previousChainLength: 0,  // Not needed for decryption
                suiteId: 1  // Classic suite
            )

            let encoder = MessagePackEncoder()
            let serialized = try encoder.encode(ratchetMsg)

            let plaintext = try core.decryptMessage(sessionId: sessionId, ciphertext: [UInt8](serialized))
            Log.debug("✅ Message decrypted successfully", category: "CryptoManager")
            return plaintext
        } catch let error as CryptoError {
            Log.error("❌ Decryption failed: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        } catch {
            Log.error("❌ Unexpected decryption error: \(error)", category: "CryptoManager")
            throw CryptoManagerError.decryptionFailed
        }
    }
}

// MARK: - Error Types

/// CryptoManager-specific errors (wraps UniFFI CryptoError)
enum CryptoManagerError: Error, LocalizedError {
    case coreNotInitialized
    case sessionNotFound
    case sessionInitializationFailed
    case encryptionFailed
    case decryptionFailed
    case invalidCiphertext
    case invalidKeyData

    var errorDescription: String? {
        switch self {
        case .coreNotInitialized:
            return "Crypto core is not initialized"
        case .sessionNotFound:
            return "No session found for this user"
        case .sessionInitializationFailed:
            return "Failed to initialize session"
        case .encryptionFailed:
            return "Failed to encrypt message"
        case .decryptionFailed:
            return "Failed to decrypt message"
        case .invalidCiphertext:
            return "Invalid ciphertext format"
        case .invalidKeyData:
            return "Invalid key data"
        }
    }
}
